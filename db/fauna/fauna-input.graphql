
type User @collection(name: "users")  {
  email: String! @unique(index: "unique_user_email")
  auth_uid: String!
  profiles: [Profile!]! @relation(name: "user_profile")
}

type Profile @collection(name: "profiles")  {
  user: User! @relation(name: "user_profile")
  display_name: String! @unique(index: "profile_display_name")
  pronoun: String
  circles: [Circle!]! @relation(name: "circle_members")
}

type Circle @collection(name: "circles")  {
  parent: Circle
  name: String!
  proposal: Proposal!
  location: Location
  members: [Profile!]! @relation(name: "circle_members")
  posts: [Post!]! @relation(name: "circle_posts")
  documents: [Document!]! @relation(name: "circle_documents")
  events: [Event!]! @relation(name: "circle_events")
}

type Area @collection(name: "areas") {
  circle: Circle!
  name: String!
  proposal: Proposal!
  location: Location
  posts: [Post!]! @relation(name: "area_posts")
  documents: [Document!]! @relation(name: "area_documents")
  events: [Event!]! @relation(name: "area_events")
}

type Location @collection(name: "locations") {
  name: String!
  address: String
  lat: Float
  lon: Float
}

type Event {
  name: String!
  proposal: Proposal!
  location: Location
  circle: Circle @relation(name: "circle_events")
  area: Area @relation(name: "area_events")
  starts_at: Time!
  ends_at: Time!
}

type Proposal @collection(name: "proposals")  {
  circle: Circle!
  voting_model: VotingModel!
  minimum_participation_rate: Float!
  votes: [Vote!]! @relation(name: "proposal_votes")
  active: Boolean!
  created_at: Time!
  resolved_at: Time
  outcome: ProposalOutcome
}

# an individual vote by a member of a circle, can be proxied
type Vote @collection(name: "votes")  {
  proposal: Proposal! @relation(name: "proposal_votes")
  profile: Profile!
  proxy_to: Profile
  approve: Boolean
}

type Document @collection(name: "documents") {
  circle: Circle @relation(name: "circle_documents")
  area: Area @relation(name: "area_documents")
  proposal: Proposal!
  title: String!
  current_revision: Revision!
  revisions: [Revision!]! @relation(name: "document_revisions")
}

type Revision @collection(name: "revisions") {
  author: Profile!
  proposal: Proposal!
  document: Document! @relation(name: "document_revisions")
  revision_title: String!
  content: String!
  created_at: Time!
}

type Post @collection(name: "posts")  {
  author: Profile!
  circle: Circle @relation(name: "circle_posts")
  area: Area @relation(name: "area_posts")
  subject: String!
  content: String!
  created_at: Time!
  comments: [Comment!]! @relation(name: "post_comments")
}

type Comment @collection(name: "comments") {
  post: Post! @relation(name: "post_comments")
  author: Profile!
  content: String!
  created_at: Time!
}

enum VotingModel {
    CONSENSUS
    CONSENT
}

enum ProposalOutcome {
    APPROVED
    REJECTED
    UNDECIDED
}

type Query {
  # calculate outcome according to voting model and current choices made
  calculateOutcome(proposal_id: ID!): ProposalOutcome @resolver(name: "proposal_outcome")
}

type Mutation {
  # adopts a proposed revision if vote approved, removes if rejected, returns ProposalOutcome
  resolveProposedRevision(revision_id: ID!): ProposalOutcome @resolver(name: "resolve_proposed_revision")
}
